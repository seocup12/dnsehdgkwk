<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>러닝 커뮤니티 피드</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        /* Inter 폰트 설정 */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6;
        }

        /* 모바일 뷰 컨테이너 스타일 */
        .mobile-container {
            width: 100%;
            max-width: 480px;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            border-radius: 1.5rem;
            overflow: hidden;
        }
        
        /* 코스 라인에 그림자 효과 추가 */
        .course-path {
            filter: drop-shadow(0 0 2px rgba(0, 0, 0, 0.5));
        }

        /* 댓글 영역 스크롤바 숨기기 (선택 사항) */
        .comments-scroll-area::-webkit-scrollbar {
            display: none;
        }
        .comments-scroll-area {
            -ms-overflow-style: none; /* IE and Edge */
            scrollbar-width: none; /* Firefox */
        }

        /* 좋아요 버튼 애니메이션 */
        .like-btn:hover .lucide-heart {
            transform: scale(1.1);
            transition: transform 0.1s ease-in-out;
        }

        /* 답글 깊이 표시 */
        .reply-indent {
            margin-left: 1.5rem; /* 24px */
            padding-left: 0.75rem; /* 12px */
            border-left: 2px solid #e5e7eb; /* gray-200 */
        }
    </style>
</head>
<body class="min-h-screen flex justify-center py-6 sm:py-10">
    <!-- 메인 모바일 컨테이너 -->
    <div id="app" class="mobile-container bg-white">
        
        <!-- 앱 헤더 -->
        <header class="p-4 bg-white border-b border-gray-200 sticky top-0 z-10 flex justify-between items-center">
            <h1 class="text-2xl font-extrabold text-indigo-600">Run<span class="text-gray-800">Feed</span></h1>
            <p id="user-info-display" class="text-xs text-gray-500">인증 중...</p>
        </header>

        <main class="p-4 pt-0">
            <!-- 1. 새 포스트 생성 영역 -->
            <div id="post-creator" class="bg-white shadow-lg rounded-xl p-4 my-4">
                <div class="flex items-center space-x-3 mb-4">
                    <div id="creator-avatar" class="w-10 h-10 bg-indigo-500 rounded-full flex items-center justify-center text-white font-bold text-sm">
                        R
                    </div>
                    <span id="creator-username" class="font-semibold text-gray-800">Runner...</span>
                </div>
                
                <div id="image-preview-area" class="relative w-full aspect-[4/3] rounded-lg overflow-hidden bg-gray-200 cursor-pointer mb-3 flex flex-col items-center justify-center text-gray-500 hover:bg-gray-300 transition duration-150">
                    <i data-lucide="plus-circle" class="w-8 h-8 mb-2"></i>
                    <span class="font-medium">사진 첨부 (갤러리/파일)</span>
                </div>

                <form id="post-form">
                    <input type="file" id="image-upload" accept="image/*" class="hidden">
                    <textarea
                        id="post-caption"
                        placeholder="오늘의 러닝 기록을 남겨보세요..."
                        class="w-full p-3 border border-gray-300 rounded-lg resize-none focus:ring-2 focus:ring-indigo-500 outline-none mb-3 text-sm"
                        rows="2"
                    ></textarea>
                    <button 
                        type="submit" 
                        id="post-submit-btn"
                        disabled
                        class="w-full bg-indigo-600 text-white py-2 rounded-lg font-semibold hover:bg-indigo-700 transition duration-150 disabled:bg-indigo-300"
                    >
                        게시하기
                    </button>
                </form>
            </div>

            <!-- 2. 피드 목록 영역 -->
            <h2 class="text-lg font-bold text-gray-800 my-4 border-b pb-2">커뮤니티 활동 피드</h2>
            
            <div id="loading-indicator" class="text-center py-10 text-gray-500">데이터를 불러오는 중입니다...</div>
            <div id="feed-list" class="space-y-6">
                <!-- 피드 아이템이 여기에 동적으로 추가됩니다 -->
            </div>
            <div id="empty-feed-message" class="hidden text-center py-10 text-gray-500">
                <p class="text-lg font-semibold">아직 게시물이 없습니다!</p>
                <p class="text-sm">위에서 첫 번째 피드를 올려보세요.</p>
            </div>
        </main>
    </div>

    <!-- Firebase SDK 및 앱 로직 -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { 
            getFirestore, collection, query, orderBy, onSnapshot, 
            doc, addDoc, updateDoc, arrayUnion, arrayRemove, getDocs
        } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // ---------- 설정 및 전역 변수 ----------
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
        
        let app, db, auth;
        let userId = null;
        let username = 'Runner' + Math.floor(Math.random() * 900 + 100);
        let isAuthReady = false;

        const PLACEHOLDER_IMAGE = "https://placehold.co/600x400/0f172a/ffffff?text=Add+Your+Run+Photo";
        const SIMULATED_RUN_PATH = "M 10 80 Q 30 60, 50 70 T 90 50";
        const DISTANCE_TEXT = "5.2 KM";
        
        // DOM 요소
        const feedList = document.getElementById('feed-list');
        const loadingIndicator = document.getElementById('loading-indicator');
        const emptyFeedMessage = document.getElementById('empty-feed-message');
        const postForm = document.getElementById('post-form');
        const imageUpload = document.getElementById('image-upload');
        const imagePreviewArea = document.getElementById('image-preview-area');
        const postCaption = document.getElementById('post-caption');
        const postSubmitBtn = document.getElementById('post-submit-btn');
        const userInfoDisplay = document.getElementById('user-info-display');
        const creatorAvatar = document.getElementById('creator-avatar');
        const creatorUsername = document.getElementById('creator-username');

        let currentImagePreview = null;
        let currentImageFile = null;
        let currentReplyInput = null; // 현재 활성화된 답글 입력 필드 (DOM 요소)

        // ---------- Firebase 초기화 및 인증 ----------
        
        try {
            app = initializeApp(firebaseConfig);
            db = getFirestore(app);
            auth = getAuth(app);
            console.log("Firebase 초기화 완료");
        } catch (error) {
            console.error("Firebase 초기화 실패:", error);
        }

        /**
         * Firebase 인증 상태를 확인하고 Firestore 리스너를 시작합니다.
         */
        onAuthStateChanged(auth, async (user) => {
            if (user) {
                userId = user.uid;
                isAuthReady = true;
                userInfoDisplay.textContent = `UserID: ${userId.substring(0, 8)}...`;
                creatorAvatar.textContent = username.charAt(0);
                creatorUsername.textContent = username;
                
                // 인증 완료 후 피드 리스너 시작
                setupFeedListener();
            } else {
                try {
                    if (initialAuthToken) {
                        await signInWithCustomToken(auth, initialAuthToken);
                    } else {
                        await signInAnonymously(auth);
                    }
                } catch (error) {
                    console.error("인증 실패, 익명 로그인 시도:", error);
                }
            }
        });

        // ---------- 포스트 생성 및 이벤트 핸들러 ----------

        imagePreviewArea.addEventListener('click', () => {
            imageUpload.click();
        });

        imageUpload.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                currentImageFile = file;
                const reader = new FileReader();
                reader.onloadend = () => {
                    currentImagePreview = reader.result;
                    renderPostCreatorPreview();
                };
                reader.readAsDataURL(file);
            }
        });
        
        postCaption.addEventListener('input', () => {
            postSubmitBtn.disabled = !(postCaption.value.trim() || currentImageFile);
        });

        /**
         * 포스트 생성 영역의 이미지 프리뷰를 렌더링합니다.
         */
        function renderPostCreatorPreview() {
            imagePreviewArea.innerHTML = '';
            if (currentImagePreview) {
                imagePreviewArea.classList.remove('flex-col', 'justify-center', 'text-gray-500');
                imagePreviewArea.innerHTML = `
                    <img src="${currentImagePreview}" alt="Post preview" class="w-full h-full object-cover absolute inset-0 opacity-80" />
                    <div class="absolute inset-0">
                        <svg class="absolute inset-0 w-full h-full" viewBox="0 0 100 100" preserveAspectRatio="none">
                            <path 
                                d="${SIMULATED_RUN_PATH}" 
                                stroke="white" 
                                stroke-width="2" 
                                fill="none" 
                                class="course-path" 
                            />
                        </svg>
                        <div class="absolute bottom-4 left-4 bg-black/50 text-white text-xs font-bold px-2 py-1 rounded-full">
                            ${DISTANCE_TEXT}
                        </div>
                    </div>
                `;
            } else {
                imagePreviewArea.classList.add('flex-col', 'justify-center', 'text-gray-500');
                imagePreviewArea.innerHTML = `
                    <i data-lucide="plus-circle" class="w-8 h-8 mb-2"></i>
                    <span class="font-medium">사진 첨부 (갤러리/파일)</span>
                `;
            }
            // Lucide 아이콘 다시 렌더링 (동적으로 추가된 요소에 대해)
            lucide.createIcons();
        }


        postForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            if (!userId) return console.error("사용자 인증 대기 중...");

            const caption = postCaption.value.trim();
            const imageUrl = currentImagePreview || PLACEHOLDER_IMAGE;

            if (!caption && imageUrl === PLACEHOLDER_IMAGE) return;

            try {
                const postsCollectionPath = `artifacts/${appId}/public/data/activityFeed`;
                await addDoc(collection(db, postsCollectionPath), {
                    userId: userId,
                    username: username,
                    imageUrl: imageUrl,
                    caption: caption,
                    coursePathData: SIMULATED_RUN_PATH,
                    distance: DISTANCE_TEXT,
                    likes: [],
                    timestamp: Date.now(),
                });
                
                // 폼 초기화
                postCaption.value = '';
                currentImagePreview = null;
                currentImageFile = null;
                postSubmitBtn.disabled = true;
                renderPostCreatorPreview();

                console.log("포스트 추가 완료");
            } catch (error) {
                console.error("포스트 추가 오류:", error);
            }
        });

        // ---------- Firestore 실시간 피드 리스너 ----------
        
        /**
         * Firestore에서 실시간으로 포스트 데이터를 가져오고 UI를 업데이트합니다.
         */
        function setupFeedListener() {
            const postsCollectionPath = `artifacts/${appId}/public/data/activityFeed`;
            const postsQuery = query(collection(db, postsCollectionPath), orderBy('timestamp', 'desc'));

            onSnapshot(postsQuery, async (snapshot) => {
                loadingIndicator.classList.add('hidden');
                
                if (snapshot.empty) {
                    emptyFeedMessage.classList.remove('hidden');
                    feedList.innerHTML = '';
                    return;
                }

                emptyFeedMessage.classList.add('hidden');
                const fetchedPosts = [];
                const promises = snapshot.docs.map(async (postDoc) => {
                    const post = { id: postDoc.id, ...postDoc.data() };
                    post.comments = await fetchComments(post.id, postsCollectionPath);
                    fetchedPosts.push(post);
                });

                await Promise.all(promises);
                
                // 시간 순서에 맞춰서 렌더링 (내림차순)
                fetchedPosts.sort((a, b) => b.timestamp - a.timestamp); 
                renderFeed(fetchedPosts);
            }, (error) => {
                console.error("Firestore 피드 데이터 가져오기 오류:", error);
                loadingIndicator.textContent = "데이터 로딩 중 오류 발생.";
            });
        }
        
        /**
         * 특정 포스트의 댓글을 가져와 계층 구조로 정리합니다.
         * @param {string} postId - 포스트 ID
         * @param {string} baseCollectionPath - 기본 컬렉션 경로
         * @returns {Promise<Array>} 계층 구조로 정리된 댓글 배열
         */
        async function fetchComments(postId, baseCollectionPath) {
            const commentsCollectionPath = `${baseCollectionPath}/${postId}/comments`;
            const commentsQuery = query(collection(db, commentsCollectionPath), orderBy('timestamp', 'asc'));
            
            const commentsSnapshot = await getDocs(commentsQuery);
            const comments = commentsSnapshot.docs.map(commentDoc => ({
                id: commentDoc.id,
                ...commentDoc.data(),
                replies: []
            }));
            
            // 댓글을 계층 구조(답글)로 정리
            const commentMap = {};
            const rootComments = [];
            
            comments.forEach(comment => {
                commentMap[comment.id] = comment;
                
                if (comment.parentId) {
                    if (commentMap[comment.parentId]) {
                        commentMap[comment.parentId].replies.push(comment);
                    }
                } else {
                    rootComments.push(comment);
                }
            });
            
            return rootComments;
        }


        // ---------- UI 렌더링 함수 ----------

        /**
         * 전체 피드 목록을 렌더링합니다.
         * @param {Array<Object>} posts - 포스트 데이터 배열
         */
        function renderFeed(posts) {
            feedList.innerHTML = '';
            posts.forEach(post => {
                const postElement = createFeedItemElement(post);
                feedList.appendChild(postElement);
            });
            // Lucide 아이콘 다시 렌더링
            lucide.createIcons();
        }

        /**
         * 단일 포스트 아이템 DOM 요소를 생성합니다.
         * @param {Object} post - 단일 포스트 데이터
         * @returns {HTMLElement} 포스트 아이템 DOM 요소
         */
        function createFeedItemElement(post) {
            const isLiked = post.likes.includes(userId);
            const totalComments = post.comments.reduce((acc, c) => acc + 1 + c.replies.length, 0);

            const itemDiv = document.createElement('div');
            itemDiv.id = `post-${post.id}`;
            itemDiv.className = "bg-white shadow-md rounded-xl overflow-hidden border border-gray-100";
            
            itemDiv.innerHTML = `
                <!-- 헤더 -->
                <div class="flex items-center p-4">
                    <div class="w-10 h-10 bg-indigo-500 rounded-full flex items-center justify-center text-white font-bold text-sm mr-3">
                        ${post.username.charAt(0)}
                    </div>
                    <div>
                        <p class="font-semibold text-gray-800">${post.username}</p>
                        <p class="text-xs text-gray-500">${new Date(post.timestamp).toLocaleString('ko-KR')}</p>
                    </div>
                </div>

                <!-- 이미지 및 코스 오버레이 -->
                <div class="relative w-full aspect-[4/3] bg-gray-900">
                    <img 
                        src="${post.imageUrl || PLACEHOLDER_IMAGE}" 
                        alt="Run Activity" 
                        class="w-full h-full object-cover opacity-80" 
                        onerror="this.onerror=null;this.src='${PLACEHOLDER_IMAGE}';"
                    />
                    <div class="absolute inset-0">
                        <svg class="absolute inset-0 w-full h-full" viewBox="0 0 100 100" preserveAspectRatio="none">
                            <path 
                                d="${post.coursePathData || SIMULATED_RUN_PATH}"
                                stroke="white" 
                                stroke-width="2" 
                                fill="none" 
                                class="course-path"
                            />
                        </svg>
                        <div class="absolute bottom-4 left-4 bg-black/50 text-white text-sm font-bold px-3 py-1 rounded-full">
                            ${post.distance || DISTANCE_TEXT}
                        </div>
                    </div>
                </div>

                <!-- 액션 버튼 -->
                <div class="flex items-center p-4 space-x-4 border-b border-gray-100">
                    <button class="like-btn flex items-center space-x-1 transition duration-150" data-post-id="${post.id}" data-is-liked="${isLiked}">
                        <i data-lucide="heart" class="w-6 h-6 ${isLiked ? 'text-red-500 fill-red-500' : 'text-gray-400'}"></i>
                        <span class="text-sm font-medium">${post.likes.length}</span>
                    </button>

                    <button class="comment-toggle-btn flex items-center space-x-1 text-gray-600 transition duration-150 hover:text-indigo-600">
                        <i data-lucide="message-circle" class="w-6 h-6"></i>
                        <span class="text-sm font-medium">${totalComments}</span>
                    </button>
                </div>

                <!-- 캡션 -->
                <div class="p-4">
                    <p class="text-sm leading-relaxed">
                        <span class="font-semibold mr-1">${post.username}</span>
                        ${post.caption}
                    </p>
                </div>

                <!-- 댓글 섹션 (초기에는 숨김) -->
                <div class="comments-section hidden p-4 pt-0">
                    <div class="mt-4 border-t border-gray-100 pt-4">
                        <h3 class="font-semibold text-base mb-2">댓글 ${totalComments}개</h3>
                        
                        <!-- 댓글 목록 -->
                        <div class="comments-scroll-area max-h-64 overflow-y-auto pr-2" id="comments-list-${post.id}">
                            ${renderComments(post.comments, post.id, 0)}
                        </div>
                        
                        <!-- 새 댓글 입력 (루트 댓글) -->
                        ${renderCommentInput(post.id, null)}
                    </div>
                </div>
            `;
            
            // 이벤트 리스너 추가
            itemDiv.querySelector('.like-btn').addEventListener('click', () => toggleLike(post.id, post.likes));
            itemDiv.querySelector('.comment-toggle-btn').addEventListener('click', () => {
                const commentsSection = itemDiv.querySelector('.comments-section');
                commentsSection.classList.toggle('hidden');
            });

            return itemDiv;
        }

        /**
         * 댓글 목록 HTML 문자열을 재귀적으로 생성합니다.
         * @param {Array<Object>} comments - 댓글 데이터 배열
         * @param {string} postId - 포스트 ID
         * @param {number} depth - 현재 댓글의 깊이 (0: 루트, 1: 답글)
         * @returns {string} 댓글 HTML 문자열
         */
        function renderComments(comments, postId, depth) {
            let html = '';
            
            if (comments.length === 0 && depth === 0) {
                return '<p class="text-gray-500 text-sm">첫 번째 댓글을 남겨보세요!</p>';
            }

            comments.forEach(comment => {
                const isReply = depth > 0;
                const indentClass = isReply ? 'reply-indent mt-2' : 'mt-3';
                
                html += `
                    <div class="comment-item text-sm ${indentClass}">
                        <div class="flex items-start">
                            <div class="w-6 h-6 rounded-full flex items-center justify-center text-white text-xs font-bold ${isReply ? 'bg-green-500' : 'bg-pink-500'} mr-2 flex-shrink-0">
                                ${comment.username.charAt(0)}
                            </div>
                            <div class="flex-grow">
                                <p class="leading-tight">
                                    <span class="font-semibold mr-1">${comment.username}</span>
                                    ${comment.text}
                                </p>
                                <div class="flex space-x-2 text-xs text-gray-500 mt-1">
                                    <span>${new Date(comment.timestamp).toLocaleTimeString('ko-KR', { hour: '2-digit', minute: '2-digit' })}</span>
                                    <button 
                                        class="reply-btn font-semibold hover:text-indigo-600" 
                                        data-post-id="${postId}" 
                                        data-comment-id="${comment.id}"
                                    >
                                        답글 달기
                                    </button>
                                </div>
                                <div id="reply-input-area-${comment.id}" class="mt-2">
                                    <!-- 답글 입력 필드가 여기에 동적으로 렌더링됩니다 -->
                                </div>
                                
                                <!-- 답글 렌더링 -->
                                ${comment.replies.length > 0 ? renderComments(comment.replies, postId, depth + 1) : ''}
                            </div>
                        </div>
                    </div>
                `;
            });
            return html;
        }

        /**
         * 댓글 입력 폼 HTML 문자열을 생성합니다.
         * @param {string} postId - 포스트 ID
         * @param {string|null} parentId - 부모 댓글 ID (null이면 루트 댓글)
         * @returns {string} 댓글 입력 폼 HTML 문자열
         */
        function renderCommentInput(postId, parentId) {
            const isReply = parentId !== null;
            return `
                <form class="comment-input-form flex space-x-2 mt-2" data-post-id="${postId}" data-parent-id="${parentId || ''}">
                    <input
                        type="text"
                        placeholder="${isReply ? '답글 쓰기...' : '댓글 달기...'}"
                        class="comment-text-input flex-grow p-2 text-sm border border-gray-200 rounded-full focus:ring-1 focus:ring-indigo-400 outline-none"
                    />
                    <button type="submit" class="text-indigo-600 p-2 rounded-full hover:bg-indigo-50 transition duration-150" aria-label="댓글 전송">
                        <i data-lucide="send" class="w-5 h-5"></i>
                    </button>
                    ${isReply ? `<button type="button" class="cancel-reply-btn text-gray-500 p-2 rounded-full hover:bg-gray-100 transition duration-150" aria-label="답글 취소">
                        <i data-lucide="corner-up-left" class="w-5 h-5"></i>
                    </button>` : ''}
                </form>
            `;
        }
        
        // ---------- 이벤트 위임 및 동적 이벤트 핸들러 설정 ----------

        /**
         * 좋아요 버튼 토글 Firestore 로직
         * @param {string} postId - 포스트 ID
         * @param {Array<string>} currentLikes - 현재 좋아요를 누른 사용자 ID 배열
         */
        async function toggleLike(postId, currentLikes) {
            if (!userId) return console.error("사용자 인증 대기 중...");

            try {
                const postRef = doc(db, `artifacts/${appId}/public/data/activityFeed`, postId);
                
                if (currentLikes.includes(userId)) {
                    // 좋아요 취소
                    await updateDoc(postRef, {
                        likes: arrayRemove(userId)
                    });
                } else {
                    // 좋아요
                    await updateDoc(postRef, {
                        likes: arrayUnion(userId)
                    });
                }
            } catch (error) {
                console.error("좋아요 토글 오류:", error);
            }
        }

        /**
         * 댓글/답글 추가 Firestore 로직
         * @param {string} postId - 포스트 ID
         * @param {string} text - 댓글 내용
         * @param {string|null} parentId - 부모 댓글 ID
         */
        async function addComment(postId, text, parentId = null) {
            if (!userId || !text.trim()) return;
            
            try {
                const commentsCollectionPath = `artifacts/${appId}/public/data/activityFeed/${postId}/comments`;
                await addDoc(collection(db, commentsCollectionPath), {
                    userId: userId,
                    username: username,
                    text: text,
                    parentId: parentId,
                    timestamp: Date.now(),
                });

                // 답글 입력 필드 닫기 (있다면)
                if (currentReplyInput) {
                    currentReplyInput.innerHTML = '';
                    currentReplyInput = null;
                }
            } catch (error) {
                console.error("댓글 추가 오류:", error);
            }
        }

        // 전체 피드 컨테이너에 이벤트 위임 (댓글 폼 및 답글 버튼)
        feedList.addEventListener('click', (e) => {
            const replyBtn = e.target.closest('.reply-btn');
            if (replyBtn) {
                e.preventDefault();
                const postId = replyBtn.dataset.postId;
                const commentId = replyBtn.dataset.commentId;
                const replyArea = document.getElementById(`reply-input-area-${commentId}`);

                // 이전에 활성화된 답글 입력 필드가 있으면 닫기
                if (currentReplyInput && currentReplyInput !== replyArea) {
                    currentReplyInput.innerHTML = '';
                }

                if (replyArea.innerHTML) {
                    // 이미 열려있으면 닫기
                    replyArea.innerHTML = '';
                    currentReplyInput = null;
                } else {
                    // 새로 열기
                    replyArea.innerHTML = renderCommentInput(postId, commentId);
                    currentReplyInput = replyArea;
                    lucide.createIcons();
                }
            }
            
            const cancelReplyBtn = e.target.closest('.cancel-reply-btn');
            if (cancelReplyBtn) {
                e.preventDefault();
                if (currentReplyInput) {
                    currentReplyInput.innerHTML = '';
                    currentReplyInput = null;
                }
            }
        });

        feedList.addEventListener('submit', (e) => {
            const commentForm = e.target.closest('.comment-input-form');
            if (commentForm) {
                e.preventDefault();
                const postId = commentForm.dataset.postId;
                const parentId = commentForm.dataset.parentId || null;
                const input = commentForm.querySelector('.comment-text-input');
                const text = input.value;

                if (text) {
                    addComment(postId, text, parentId);
                    input.value = '';
                }
            }
        });

        // 초기 렌더링 (DOMContentLoaded가 필요 없도록 모듈 스크립트로 구성)
        document.addEventListener('DOMContentLoaded', () => {
             // 페이지 로드 시 Lucide 아이콘 초기화
             lucide.createIcons();
        });
        
        // 페이지 로드 후 Lucide 아이콘 초기화 (동적 요소용)
        window.onload = () => {
             lucide.createIcons();
        };

    </script>
</body>
</html>