<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  
  <title>PokÃ©mon Battle Final Fix</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Chakra+Petch:wght@700&family=Black+Han+Sans&display=swap');

    :root { --hp-green: #00ff66; --hp-yellow: #ffcc00; --hp-red: #ff3300; }

    html, body { 
      margin: 0; padding: 0; 
      width: 100%; height: 100%; 
      overflow: hidden; 
      background-color: #222; /* ìµœí›„ì˜ ìˆ˜ë‹¨ ë°°ê²½ìƒ‰ */
      font-family: 'Chakra Petch', sans-serif; 
      user-select: none; -webkit-user-select: none; 
      touch-action: none;
    }

    /* === ìŠ¤í…Œì´ì§€ === */
    #game-stage {
      position: relative; width: 100%; 
      height: 100vh; height: 100dvh;
      
      /* [ìˆ˜ì •ë¨] ì•ˆì •ì ì¸ ê³ í™”ì§ˆ ìˆ²ì† ê²°íˆ¬ì¥ ì´ë¯¸ì§€ë¡œ êµì²´ */
      /* ì´ë¯¸ì§€ê°€ ë¡œë”©ë˜ê¸° ì „ì—ëŠ” ì§„í•œ ë…¹ìƒ‰ ê·¸ë¼ë°ì´ì…˜ì´ ë¨¼ì € ë³´ì„ */
      background: 
        linear-gradient(to bottom, rgba(0,0,0,0.3), rgba(0,0,0,0.6)),
        url('https://cmsassets.rgpub.io/sanity/images/dsfx7636/news_live/fb316159b327db17fb08c333386e8bdfeff304fe-1731x1080.jpg');
      
      background-size: cover; background-position: center;
      overflow: hidden; 
      perspective: 1000px;
      transform: translateZ(0); /* ì•„ì´í° ë Œë”ë§ ê°•ì œ */
    }
    
    #speed-lines {
      position: absolute; inset: 0; pointer-events: none; z-index: 50;
      background: repeating-conic-gradient(from 0deg, transparent 0deg, transparent 10deg, rgba(255,255,255,0.1) 10deg, rgba(255,255,255,0.1) 12deg);
      opacity: 0; transition: opacity 0.2s; 
      mix-blend-mode: overlay;
    }

    #flash-overlay { position: absolute; inset: 0; background: white; opacity: 0; pointer-events: none; z-index: 9999; mix-blend-mode: overlay; transition: opacity 0.05s; }
    #game-stage::after { content: ''; position: absolute; inset: 0; background: radial-gradient(circle, transparent 50%, rgba(0,0,0,0.5) 100%); pointer-events: none; z-index: 40; }

    /* === ìœ ë‹› ì»¨í…Œì´ë„ˆ === */
    .pokemon-unit {
      position: absolute; width: 22vmin; height: 22vmin;
      transform-style: preserve-3d; transition: opacity 0.5s;
      display: flex; flex-direction: column; align-items: center; justify-content: flex-end;
      overflow: visible !important;
      -webkit-backface-visibility: hidden; backface-visibility: hidden;
    }

    /* ë°°ì¹˜ ì¢Œí‘œ */
    #enemy-unit-0 { top: 15%; right: 8%; z-index: 10; }
    #enemy-unit-1 { top: 38%; right: 8%; z-index: 20; }
    #enemy-unit-2 { top: 62%; right: 8%; z-index: 30; }
    #player-unit-0 { top: 15%; left: 8%; z-index: 10; }
    #player-unit-1 { top: 38%; left: 8%; z-index: 20; }
    #player-unit-2 { top: 62%; left: 8%; z-index: 30; }

    .poke-img-wrapper { position: relative; width: 100%; height: 100%; transform-style: preserve-3d; }
    
    .poke-img {
      width: auto; height: auto; max-width: 170%; max-height: 150%;
      object-fit: contain; filter: drop-shadow(0 1vmin 2vmin rgba(0,0,0,0.7));
      transform-origin: bottom center; transition: transform 0.3s, filter 0.3s;
      -webkit-transform: translateZ(0); transform: translateZ(0);
    }
    .shadow { position: absolute; bottom: 0; left: 50%; transform: translateX(-50%) rotateX(70deg); width: 80%; height: 20%; background: radial-gradient(rgba(0,0,0,0.8), transparent 70%); z-index: -1; }

    /* === ì²´ë ¥ë°” (ê°€ì‹œì„± í™•ë³´) === */
    .mini-hud {
      position: absolute; 
      top: -40%; left: 50%; 
      width: 140%; padding: 4px;
      background: rgba(0, 0, 0, 0.85); 
      border: 2px solid #fff;
      border-radius: 8px; text-align: center; 
      z-index: 9999; 
      box-shadow: 0 4px 10px rgba(0,0,0,0.8);
      transform: translateX(-50%) translateZ(100px); -webkit-transform: translateX(-50%) translateZ(100px);
    }
    .hud-name { 
      font-size: 2.5vmin; color: #fff; font-weight: 900; 
      text-shadow: 1px 1px 0 #000; display:block; 
      white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
      font-family: 'Chakra Petch', sans-serif;
    }
    .hp-bg { width: 100%; height: 1.5vmin; background: #444; border-radius: 3px; overflow: hidden; border: 1px solid #888; margin-top: 2px; }
    .hp-fill { width: 100%; height: 100%; background: var(--hp-green); transition: width 0.3s ease-out; }

    /* === ìŠ¤í‚¬ ì´í™íŠ¸ === */
    .skill-beam { 
      position: absolute; transform-origin: center left; z-index: 1000; pointer-events: none; opacity: 0.9; 
      mix-blend-mode: screen; 
    }

    .beam-fire {
      height: 60px;
      background: linear-gradient(90deg, #fff 0%, #ffaa00 20%, #ff0000 100%);
      filter: blur(3px) contrast(1.5) drop-shadow(0 0 20px orange);
      clip-path: polygon(0% 30%, 100% 0%, 100% 100%, 0% 70%);
      animation: beamPulse 0.1s infinite;
    }
    .beam-water {
      height: 80px;
      background: repeating-linear-gradient(90deg, #00f, #0ff 20%, #00f 40%);
      background-size: 200% 100%; border: 3px solid white; box-shadow: 0 0 30px cyan;
      animation: waterFlow 0.3s infinite linear;
    }
    .beam-electric {
      height: 15px; background: white; box-shadow: 0 0 30px yellow;
      clip-path: polygon(0% 40%, 20% 0%, 40% 60%, 60% 10%, 80% 70%, 100% 50%, 100% 50%, 80% 100%, 60% 40%, 40% 90%, 20% 30%, 0% 60%);
      animation: thunderFlash 0.05s infinite;
    }
    .projectile { position: absolute; width: 80px; height: 80px; z-index: 1000; background: radial-gradient(circle, #fff, transparent); filter: blur(2px); }
    .proj-wind { border-radius: 50%; box-shadow: 0 0 20px white; transform: scaleX(2); }
    .proj-earth { background: #5d4037; border-radius: 10px; box-shadow: 0 0 10px #3e2723; }

    @keyframes beamPulse { 0% { opacity: 0.8; transform: scaleY(1); } 100% { opacity: 1; transform: scaleY(1.3); } }
    @keyframes waterFlow { 0% { background-position: 0% 0%; } 100% { background-position: -100% 0%; } }
    @keyframes thunderFlash { 0% { opacity: 1; } 50% { opacity: 0.5; } 100% { opacity: 1; } }

    /* íƒ€ê²© ì´í™íŠ¸ */
    .impact-burst { position: absolute; width: 200px; height: 200px; transform: translate(-50%, -50%); z-index: 1100; pointer-events: none; mix-blend-mode: screen; }
    .burst-fire { background: radial-gradient(circle, #fff, orange, red, transparent); animation: burst 0.4s forwards; }
    .burst-water { background: radial-gradient(circle, #fff, cyan, blue, transparent); animation: burst 0.4s forwards; }
    .burst-electric { background: radial-gradient(circle, #fff, yellow, transparent); animation: burst 0.2s forwards; }
    .burst-earth { background: radial-gradient(circle, #fff, #795548, transparent); animation: burst 0.4s forwards; }
    @keyframes burst { 0% { transform: translate(-50%, -50%) scale(0.2); opacity: 1; } 100% { transform: translate(-50%, -50%) scale(2.5); opacity: 0; } }

    /* ì†ì„±ë³„ í”¼ê²© íš¨ê³¼ */
    .hit-fire { filter: sepia(1) saturate(7) hue-rotate(-50deg) drop-shadow(0 0 2vmin orange) brightness(1.2) !important; animation: burnShake 0.1s infinite !important; }
    .hit-water { filter: sepia(1) saturate(5) hue-rotate(180deg) drop-shadow(0 0 2vmin cyan) brightness(1.1) !important; transform: scale(0.95) !important; }
    .hit-electric { filter: sepia(1) saturate(10) hue-rotate(-10deg) drop-shadow(0 0 2vmin yellow) brightness(1.5) contrast(1.5) !important; animation: electricShock 0.08s infinite !important; }
    .hit-earth { filter: sepia(1) saturate(2) hue-rotate(-120deg) drop-shadow(0 0 1vmin #5d4037) brightness(0.8) !important; transform: translateY(5px) !important; }
    .hit-wind { filter: brightness(2) grayscale(1) drop-shadow(0 0 1vmin white) !important; opacity: 0.8; }

    @keyframes burnShake { 0% { transform: translateX(-2px); } 100% { transform: translateX(2px); } }
    @keyframes electricShock { 0% { opacity: 1; filter: brightness(2) sepia(1) hue-rotate(-10deg); } 50% { opacity: 0.6; } 100% { opacity: 1; } }

    /* ì»¨íŠ¸ë¡¤ íŒ¨ë„ */
    #controls {
      position: absolute; bottom: 0; left: 0; width: 100%; 
      height: 15vh; height: 15dvh;
      background: linear-gradient(to top, rgba(0,0,0,1), rgba(0,0,0,0.7)); 
      border-top: 2px solid #ffd700;
      display: flex; justify-content: center; align-items: center; z-index: 200;
      padding-bottom: env(safe-area-inset-bottom);
    }
    #message-box { 
      color: #fff; font-size: 4.5vmin; font-weight: 900; 
      text-shadow: 2px 2px 0 #000; text-align: center; width: 90%; 
      font-family: 'Black Han Sans', sans-serif; letter-spacing: 1px;
    }

    .camera-shake { animation: shake 0.4s cubic-bezier(.36,.07,.19,.97) both; }
    @keyframes shake { 10%, 90% { transform: translate3d(-4px, 0, 0); } 20%, 80% { transform: translate3d(4px, 0, 0); } 30%, 50%, 70% { transform: translate3d(-6px, -3px, 0); } 40%, 60% { transform: translate3d(6px, 3px, 0); } }

    #loading { 
      position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
      background: #111; color: #ffd700; z-index: 9999; 
      display: flex; justify-content: center; align-items: center; 
      font-size: 5vmin; font-weight: bold; 
      transition: opacity 0.5s;
    }
  </style>
</head>
<body>

  <div id="loading">LOADING...</div>

  <div id="game-stage">
    <div id="speed-lines"></div>
    <div id="flash-overlay"></div>
    
    <div id="enemy-unit-0" class="pokemon-unit"></div>
    <div id="enemy-unit-1" class="pokemon-unit"></div>
    <div id="enemy-unit-2" class="pokemon-unit"></div>
    <div id="player-unit-0" class="pokemon-unit"></div>
    <div id="player-unit-1" class="pokemon-unit"></div>
    <div id="player-unit-2" class="pokemon-unit"></div>
  </div>

  <div id="controls">
    <div id="message-box">READY...</div>
  </div>

  <script>
    const randomInt = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;
    const wait = (ms) => new Promise(resolve => setTimeout(resolve, ms));
    
    const SKILLS = [
      { type: 'fire', name: "ğŸ”¥ ë¶ˆëŒ€ë¬¸ì", mode: 'beam' },
      { type: 'water', name: "ğŸ’§ í•˜ì´ë“œë¡œíŒí”„", mode: 'beam' },
      { type: 'electric', name: "âš¡ 10ë§Œë³¼íŠ¸", mode: 'beam' },
      { type: 'earth', name: "ğŸª¨ ëŒ€ì§€ì˜í˜", mode: 'projectile' },
      { type: 'wind', name: "ğŸŒªï¸ ì—ì–´ìŠ¬ë˜ì‹œ", mode: 'projectile' },
      { type: 'physical', name: "ğŸ‘Š ê¸°ê°€ì„íŒ©íŠ¸", mode: 'melee' }
    ];

    class AnimeBattle {
      constructor() {
        this.playerTeam = [];
        this.enemyTeam = [];
        this.isGameOver = false;
        this.msgBox = document.getElementById('message-box');
        this.stage = document.getElementById('game-stage');
        this.speedLines = document.getElementById('speed-lines');
        this.init();
      }

      async init() {
        // [ì•„ì´í° ì•ˆì „ ì¥ì¹˜] ë¡œë”©ì´ 5ì´ˆ ì´ìƒ ê±¸ë¦¬ë©´ ê°•ì œ ì‹œì‘
        setTimeout(() => {
            if(document.getElementById('loading').style.display !== 'none') {
                document.getElementById('loading').style.display = 'none';
                // ë°ì´í„°ê°€ ì—†ë‹¤ë©´ ì¬ì‹œë„
                if(this.playerTeam.length === 0) location.reload();
            }
        }, 5000);

        const ids = Array.from({length: 6}, () => randomInt(1, 151));
        try {
          const promises = ids.map(id => fetch(`https://pokeapi.co/api/v2/pokemon/${id}`).then(res => res.json()));
          const results = await Promise.all(promises);

          this.playerTeam = results.slice(0, 3).map((data, i) => this.parseData(data, true, i));
          this.enemyTeam = results.slice(3, 6).map((data, i) => this.parseData(data, false, i));

          this.renderUnit('player', this.playerTeam);
          this.renderUnit('enemy', this.enemyTeam);

          await wait(1500);
          document.getElementById('loading').style.opacity = 0;
          setTimeout(() => document.getElementById('loading').style.display = 'none', 500);
          
          this.battleLoop();

        } catch (e) { 
            console.error(e); 
            document.getElementById('loading').innerHTML = "RETRY...";
            setTimeout(() => location.reload(), 2000);
        }
      }

      parseData(data, isPlayer, index) {
        let hp = data.stats[0].base_stat * 3 + 200;
        let name = data.name.toLowerCase().replace('-m','m').replace('-f','f').replace('mr-mime','mrmime');
        const h = data.height; 
        let scale = Math.min(Math.max(h < 5 ? 0.9 : h > 40 ? 1.35 : 1.0 + ((h-5)/60), 0.85), 1.4);
        let imgSrc = `https://play.pokemonshowdown.com/sprites/xyani/${name}.gif`;

        return {
          id: `${isPlayer?'player':'enemy'}-unit-${index}`,
          name: data.name.toUpperCase(),
          maxHp: hp, currentHp: hp, attack: data.stats[1].base_stat,
          imgSrc: imgSrc, scale: scale, isPlayer: isPlayer, isDead: false
        };
      }

      renderUnit(side, teamData) {
        teamData.forEach((unit) => {
          const div = document.getElementById(unit.id);
          if(div) {
            const transformStyle = unit.isPlayer 
              ? `scaleX(-1) rotateY(20deg) scale(${unit.scale})` 
              : `rotateY(-20deg) scale(${unit.scale})`;
            
            div.innerHTML = `
              <div class="mini-hud">
                <span class="hud-name">${unit.name}</span>
                <div class="hp-bg"><div class="hp-fill" id="hp-${unit.id}" style="width:100%"></div></div>
              </div>
              <div class="poke-img-wrapper">
                 <div class="shadow"></div>
                 <img src="${unit.imgSrc}" class="poke-img" id="img-${unit.id}" style="transform: ${transformStyle}">
              </div>
            `;
          }
        });
      }

      async battleLoop() {
        while (!this.isGameOver) {
          let allUnits = [...this.playerTeam, ...this.enemyTeam].filter(u => !u.isDead);
          if (allUnits.length === 0) break;
          allUnits.sort(() => Math.random() - 0.5);

          for (const attacker of allUnits) {
            if (this.isGameOver || attacker.isDead) continue;
            const targetTeam = attacker.isPlayer ? this.enemyTeam : this.playerTeam;
            const livingTargets = targetTeam.filter(u => !u.isDead);
            if (livingTargets.length === 0) { this.endGame(attacker.isPlayer); return; }

            const target = livingTargets[randomInt(0, livingTargets.length - 1)];
            await this.performAction(attacker, target);
            
            if (targetTeam.every(u => u.isDead)) { this.endGame(attacker.isPlayer); return; }
          }
          await wait(800);
        }
      }

      async performAction(attacker, target) {
        const skill = SKILLS[randomInt(0, SKILLS.length - 1)];
        
        let color = '#fff';
        if(skill.type === 'fire') color = '#ff3300';
        else if(skill.type === 'water') color = '#00ccff';
        else if(skill.type === 'electric') color = '#ffff00';
        else if(skill.type === 'earth') color = '#8d6e63';

        this.msgBox.innerHTML = `<span style="color:#ffd700">${attacker.name}</span>ì˜ <span style="color:${color}">${skill.name}</span>!`;

        const atkImg = document.getElementById(`img-${attacker.id}`);
        atkImg.classList.add('charging-aura');
        this.speedLines.style.opacity = 1; 
        await wait(400);
        atkImg.classList.remove('charging-aura');

        if (skill.mode === 'melee') await this.actionMelee(attacker, target);
        else if (skill.mode === 'beam') await this.actionBeam(attacker, target, skill.type);
        else await this.actionProjectile(attacker, target, skill.type);

        this.speedLines.style.opacity = 0;

        await this.applyDamage(attacker, target, skill.type);
      }

      async actionBeam(attacker, target, type) {
        const atkEl = document.getElementById(attacker.id);
        const tgtEl = document.getElementById(target.id);
        if(!atkEl || !tgtEl) return;

        const startRect = atkEl.getBoundingClientRect();
        const endRect = tgtEl.getBoundingClientRect();
        const startX = startRect.left + startRect.width/2;
        const startY = startRect.top + startRect.height/3;
        const dx = (endRect.left + endRect.width/2) - startX;
        const dy = (endRect.top + endRect.height/2) - startY;
        const dist = Math.sqrt(dx*dx + dy*dy);
        const angle = Math.atan2(dy, dx) * (180/Math.PI);

        const beam = document.createElement('div');
        beam.style.position = 'absolute';
        beam.style.left = startX + 'px';
        beam.style.top = startY + 'px';
        beam.style.width = '0px';
        beam.style.transformOrigin = 'left center';
        beam.style.transform = `rotate(${angle}deg)`;
        beam.style.zIndex = '1000';

        if(type === 'fire') beam.className = 'skill-beam beam-fire';
        else if(type === 'water') beam.className = 'skill-beam beam-water';
        else beam.className = 'skill-beam beam-electric';

        document.body.appendChild(beam);

        const shootAnim = beam.animate([
          { width: '0px' }, { width: `${dist + 50}px` }
        ], { duration: 200, fill: 'forwards', easing: 'ease-out' });

        await shootAnim.finished;

        this.stage.classList.add('camera-shake');
        this.createExplosion(tgtEl, type);
        
        const flash = document.getElementById('flash-overlay');
        flash.style.opacity = 0.8;
        setTimeout(() => flash.style.opacity = 0, 100);

        await wait(400);
        this.stage.classList.remove('camera-shake');
        beam.remove();
      }

      async actionProjectile(attacker, target, type) {
        const atkEl = document.getElementById(attacker.id);
        const tgtEl = document.getElementById(target.id);
        const startRect = atkEl.getBoundingClientRect();
        const endRect = tgtEl.getBoundingClientRect();

        const proj = document.createElement('div');
        proj.className = type === 'wind' ? 'projectile proj-wind' : 'projectile proj-earth';
        proj.style.left = (startRect.left + startRect.width/2) + 'px';
        proj.style.top = (startRect.top + startRect.height/3) + 'px';
        document.body.appendChild(proj);

        const angle = Math.atan2(endRect.top - startRect.top, endRect.left - startRect.left) * (180/Math.PI);
        
        const anim = proj.animate([
          { transform: `translate(0,0) rotate(${angle}deg) scale(0.5)` },
          { transform: `translate(${endRect.left - startRect.left}px, ${endRect.top - startRect.top}px) rotate(${angle}deg) scale(1.5)` }
        ], { duration: 300, easing: 'linear' });

        await anim.finished;
        proj.remove();
        this.createExplosion(tgtEl, type);
        this.stage.classList.add('camera-shake');
        setTimeout(() => this.stage.classList.remove('camera-shake'), 200);
      }

      async actionMelee(attacker, target) {
        const atkEl = document.getElementById(attacker.id);
        const tgtEl = document.getElementById(target.id);
        const startRect = atkEl.getBoundingClientRect();
        const endRect = tgtEl.getBoundingClientRect();
        
        const moveX = (endRect.left - startRect.left) + (attacker.isPlayer ? -50 : 50);
        const moveY = (endRect.top - startRect.top);
        
        const anim = atkEl.animate([
          { transform: 'translate3d(0,0,0)' },
          { transform: `translate3d(${moveX}px, ${moveY}px, 100px) scale(1.3)` }
        ], { duration: 150, easing: 'ease-in' });
        await anim.finished;

        this.stage.classList.add('camera-shake');
        this.createExplosion(tgtEl, 'physical');
        await wait(100);
        this.stage.classList.remove('camera-shake');

        const backAnim = atkEl.animate([
          { transform: `translate3d(${moveX}px, ${moveY}px, 100px)` },
          { transform: 'translate3d(0,0,0)' }
        ], { duration: 200, easing: 'ease-out' });
        await backAnim.finished;
      }

      createExplosion(targetEl, type) {
        const burst = document.createElement('div');
        burst.className = 'impact-burst';
        if(type === 'fire') burst.className += ' burst-fire';
        else if(type === 'water') burst.className += ' burst-water';
        else if(type === 'electric') burst.className += ' burst-electric';
        else if(type === 'earth') burst.className += ' burst-earth';
        else burst.style.background = 'radial-gradient(circle, #fff, transparent)';
        
        targetEl.appendChild(burst);
        setTimeout(() => burst.remove(), 400);
      }

      async applyDamage(attacker, target, type) {
        const targetImg = document.getElementById(`img-${target.id}`);
        
        let hitClass = '';
        if(type === 'fire') hitClass = 'hit-fire';
        else if(type === 'water') hitClass = 'hit-water';
        else if(type === 'electric') hitClass = 'hit-electric';
        else if(type === 'earth') hitClass = 'hit-earth';
        else if(type === 'wind') hitClass = 'hit-wind';

        if(hitClass) {
            targetImg.classList.add(hitClass);
            setTimeout(() => targetImg.classList.remove(hitClass), 1500);
        }

        const dmg = Math.floor(attacker.attack * 0.8 + randomInt(30, 60));
        target.currentHp = Math.max(0, target.currentHp - dmg);
        this.updateHp(target);

        await wait(500);

        if (target.currentHp <= 0) {
          target.isDead = true;
          this.msgBox.innerText = `${target.name} ë‹¤ìš´!`;
          document.getElementById(target.id).style.opacity = 0;
          await wait(1000);
        }
      }

      updateHp(unit) {
        const bar = document.getElementById(`hp-${unit.id}`);
        if(bar) {
          const pct = (unit.currentHp / unit.maxHp) * 100;
          bar.style.width = `${pct}%`;
          if(pct < 30) bar.style.background = 'var(--hp-red)';
          else if(pct < 60) bar.style.background = 'var(--hp-yellow)';
          else bar.style.background = 'var(--hp-green)';
        }
      }

      async endGame(playerWin) {
        this.isGameOver = true;
        this.msgBox.style.color = playerWin ? "#00ff00" : "#ff0000";
        this.msgBox.innerHTML = playerWin ? "ğŸ† VICTORY! ğŸ†" : "ğŸ’€ GAME OVER ğŸ’€";
        await wait(4000); location.reload();
      }
      log(text, ms) { this.msgBox.innerText = text; return wait(ms); }
    }

    const game = new AnimeBattle();
  </script>
</body>
</html>